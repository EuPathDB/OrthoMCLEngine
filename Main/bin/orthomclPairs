#!/usr/bin/perl

use strict;
use DBI;

=pod
SimilarSequences
| InterTaxonMatch
| | BestQueryTaxonScore
| | | BestInterTaxonScore
| | | | BetterHit
| | | | | InParalog ***
| | | | | | InParalog2way--------|
| | | BestHit                    |
| | | | Ortholog ***             |
| | | | | Ortholog2way           |
| | | | | | CoOrthologCandidate -|
| | | | | | | CoOrtholog ***
=cut

my $debug=1;
open (LOGFILE, ">sqlFromScript.log");

my $configFile = $ARGV[0];
my $clean = $ARGV[1];
my $restart = $ARGV[2];

my $stepCount = 1;
my @steps = (['updateMinimumEvalueExponent'],
	     ['bestQueryTaxonScore'],
	     ['qtscore_ix'],
	     ['bestInterTaxonScore'],
             ['bis_uids_ix'],
             ['uniqueSimSeqsQueryId'],
             ['ust_qids_ix'],
	     ['betterHit', ['drop table BestInterTaxonScore']],
             ['better_hit_ix'],
	     ['inParalog', ['drop table BetterHit']],
	     ['inParalogTaxon'],
	     ['inParalogOrthologTaxon'],
	     ['bestHit', ['drop table BestQueryTaxonScore']],
             ['best_hit_ix'],
	     ['ortholog', ['drop table BestHit']],
	     ['orthologTaxon', [ 'drop table OrthologTemp']],
	     ['orthologAvg'],
	     ['orthologAvgIndex'],
	     ['orthologsNormalization', ['drop table OrthologAvgScore', 'drop table OrthologTemp2']],
 	     ['inParalogTaxonAvg'],
             ['orthologUniqueId'],
             ['orthologUniqueIdIndex'],
             ['inParalogOrthologTaxonAvg', ['drop table OrthologUniqueId']],
	     ['inParalogAvg',['drop table InParalogTaxonAvg', 'drop table InParalogOrthologTaxonAvg']],
	     ['inParalogAvgIndex'],
	     ['inParalogsNormalization', ['drop table InParalogAvgScore', 'drop table InParalogTemp']],
	     ['inParalog2way'],
	     ['in2a_ix'],
	     ['in2b_ix'],
	     ['ortholog2way'],
             ['inParalogOrthologInParalog'],
             ['inParalogOrtholog'],
	     ['coOrthologCandidate', ['drop table Ortholog2Way', 'drop table InParalog2Way', 'drop table InParalogOrthologInParalog', 'drop table InParalogOrtholog']],
	     ['coOrthologNotOrtholog', ['drop table CoOrthologCandidate']],
	     ['coOrtholog', ['drop table CoOrthologNotOrtholog']],
	     ['coOrthologTaxon', [ 'drop table CoOrthologTemp']],
	     ['coOrthologAvg'],
	     ['coOrthologAvgIndex'],
	     ['coOrthologsNormalization', ['drop table CoOrthologAvgScore', 'drop table CoOrthologTaxon']],
	     ['cleanall', ['truncate table InParalog', 'truncate table Ortholog', 'truncate table CoOrtholog']],
	    );

my $stepsHash;
my $cleanHash;
for (my $i=0; $i<scalar(@steps); $i++) {
    $stepsHash->{$steps[$i]->[0]} = $i+1;
    $cleanHash->{$steps[$i]->[0]} = $steps[$i]->[1] if $steps[$i]->[1];
}

### Consider atatement to turn logging off for apidb.ortholog,coortholog, and inparalog to increase speed and use fewer resources
### Ex. Alter table apidb.ortholog s;  Can be reversed with Alter table apidb.ortholog logging;

print STDERR "\n\n============================================================================================\n";
print STDERR localtime(). " orthomclEdges " . join(' ', @ARGV) . "\n";
print STDERR "=============================================================================================\n\n";

&usage() unless $configFile;
usage() unless $clean =~ /cleanup=(yes|no|only|all)/;
$clean = $1;

my $skipPast;
if ($restart) {
  usage() unless $restart =~ /startAfter=(.*)/;
  $skipPast = $stepsHash->{$1};
  die "invalid restart arg $restart\n" unless $skipPast;
}

my $config = parseConfigFile($configFile);
my $sst = getConfig("similarSequencesTable");

my $
if (getConfig("dbVendor") eq 'oracle') {
  require DBD::Oracle;
} elsif (getConfig("dbVendor") eq 'mysql') {
  require DBD::mysql;
} else {
    die "config file '$configFile' has invalid value for dbVendor property\n";
}

my $dbh = DBI->connect(getConfig("dbConnectString"), getConfig("dbLogin"),
		       getConfig("dbPassword")) or die DBI::errstr;


commonTempTables();

inparalogs();

orthologs();

normalizeInParalogs();

coorthologs();

cleanall() if $clean eq 'all';

############################################################################

sub parseConfigFile {
  my ($configFile) = @_;

  open(F, $configFile) || die "Can't open config file '$configFile'\n";

  my $config;
  while(<F>) {
    chomp;
    next if /^\#/;
    /^(\w+)\=(.+)/ || die "illegal line in config file '$_'\n";
    my $key=$1;
    my $val=$2;
    $config->{$key} = $val;
    $val = '********' if $key eq 'dbPassword';
    print STDERR localtime() . " configuration: $key=$val\n";
  }
  return $config;
}

sub commonTempTables {
  print STDERR localtime() . " Constructing common temp tables\n"
    unless $clean eq 'only' || $clean eq 'all';
  validateInputTables();
  updateMinimumEvalueExponent();
  bestQueryTaxonScore();
}

sub inparalogs {
  print STDERR localtime() . " Constructing inParalog tables\n"
    unless $clean eq 'only' || $clean eq 'all';
  bestInterTaxonScore();
  uniqueSimSeqsQueryId();
  betterHit();
  inParalog();
}

sub orthologs {
  print STDERR localtime() . " Constructing ortholog tables\n"
    unless $clean eq 'only' || $clean eq 'all';
  bestHit();
  ortholog();
  normalizeOrthologs();
}

sub coorthologs {
  print STDERR localtime() . " Constructing coOrtholog tables\n"
    unless $clean eq 'only' || $clean eq 'all';
  inParalog2way();
  ortholog2way();
  coorthologCandidate();
  coortholog();
  normalizeCoOrthologs();
}

sub validateInputTables {

}

sub updateMinimumEvalueExponent {

    my $sql = "
select min(evalue_exp)
from $sst
where evalue_mant != 0
";

    # a little bit of a hack here.  mysql can't tolerate finding the
    # minEvalueExp in the sql that updates the table
    # so, we do it as a preprocess.
    # must explicitly avoid the preprocess if just cleaning or if skipping
    my $minEvalueExp;
    if ($clean ne 'only' && $clean ne 'all' && !$skipPast) {
      my $stmt = $dbh->prepare("$sql") or die DBI::errstr;
      $stmt->execute() or die DBI::errstr;
      ($minEvalueExp) = $stmt->fetchrow_array();
    }

  $sql = "
update $sst
set evalue_exp = ${minEvalueExp}-1
where evalue_exp = 0
";
  runSql($sql, "updating $sst, setting 0 evalue_exp to underflow value ${minEvalueExp}-1",
	 'updateMinimumEvalueExponent', '23 min');
  if ($debug==1) {print LOGFILE "\n\n$sql"};
}

sub bestQueryTaxonScore {
  my $interTaxonMatch = getConfig("interTaxonMatchView");

  my $sql = "
create table BestQueryTaxonScore as
select im.query_id, im.subject_taxon_id, low_exp.evalue_exp, min(im.evalue_mant) as evalue_mant
from $interTaxonMatch im,
     (select query_id, subject_taxon_id, min(evalue_exp) as evalue_exp
      from $interTaxonMatch
      group by query_id, subject_taxon_id) low_exp
where im.query_id = low_exp.query_id
  and im.subject_taxon_id = low_exp.subject_taxon_id
  and im.evalue_exp = low_exp.evalue_exp
group by im.query_id, im.subject_taxon_id, low_exp.evalue_exp
";
  
  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create BestQueryTaxonScore", 'bestQueryTaxonScore', '1.5 hours');

  $sql = "
create index qtscore_ix on BestQueryTaxonScore(query_id, subject_taxon_id, evalue_exp, evalue_mant)
";
  
  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create qtscore_ix index on BestQueryTaxonScore", 'qtscore_ix', '3 min'); 
}

sub  bestInterTaxonScore{

  my $sql = "
create table BestInterTaxonScore as
select im.query_id, low_exp.evalue_exp, min(im.evalue_mant) as evalue_mant
from BestQueryTaxonScore im,
     (select query_id, min(evalue_exp) as evalue_exp
      from BestQueryTaxonScore
      group by query_id) low_exp
where im.query_id = low_exp.query_id
  and im.evalue_exp = low_exp.evalue_exp
group by im.query_id, low_exp.evalue_exp
";

  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create BestInterTaxonScore", 'bestInterTaxonScore', '2 min');

 $sql = "
create index bis_uids_ix on BestInterTaxonScore(query_id)
";

  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create bis_uids_ix index on BestQueryTaxonScore", 'bis_uids_ix', '3 min');
}


sub uniqueSimSeqsQueryId {
  
   my $sql = "
create table UniqueSimSeqsQueryId as
select distinct query_id from SimilarSequences
";
  if ($debug==1) {print LOGFILE "\n\n" . localtime() . $sql};
  runSql($sql, "create UniqueSimSeqsQueryId", 'uniqueSimSeqsQueryId', '3 secs');

 $sql = "
create index ust_qids_ix on UniqueSimSeqsQueryId(query_id)
";

  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create ust_qids_ix index on UniqueSimSeqsQueryId", 'ust_qids_ix', '3 min');
}



sub  betterHit{
  my $evalueExpThreshold = getConfig("evalueExponentCutoff");
  my $percentMatchThreshold = getConfig("percentMatchCutoff");

  my $sql = "
create table BetterHit as
select s.query_id, s.subject_id,
       s.query_taxon_id as taxon_id,
       s.evalue_exp, s.evalue_mant
from $sst s, BestInterTaxonScore bis
where s.query_id != s.subject_id
  and s.query_taxon_id = s.subject_taxon_id
  and s.query_id = bis.query_id
  and s.evalue_exp <= $evalueExpThreshold
  and s.percent_match >= $percentMatchThreshold
  and (s.evalue_mant < 0.001
       or s.evalue_exp < bis.evalue_exp
       or (s.evalue_exp = bis.evalue_exp and s.evalue_mant <= bis.evalue_mant))
-- . . . or Similarity for a protein with no BestInterTaxonScore
--       (i.e. an intrataxon match for a protein with no intertaxon
--        match in the database)
union
select s.query_id, s.subject_id, s.query_taxon_id as taxon_id, s.evalue_exp, s.evalue_mant
from $sst s
where s.query_taxon_id = s.subject_taxon_id
  and s.evalue_exp <= $evalueExpThreshold
  and s.percent_match >= $percentMatchThreshold
  and s.query_id in 
     (SELECT distinct ust.query_id
      from UniqueSimSeqsQueryId ust
      LEFT OUTER JOIN BestInterTaxonScore bis ON bis.query_id = ust.query_id
      WHERE bis.query_id IS NULL)
";
  
  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create BetterHit table", 'betterHit', '30 min');

 $sql = "
create index better_hit_ix on BetterHit(query_id,subject_id)
";

  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create better_hit_ix index on BetterHit", 'better_hit_ix', '3 min');
}

sub  inParalog{
  my $sql = "
create table InParalogTemp as
select bh1.query_id as sequence_id_a, bh1.subject_id as sequence_id_b,
       bh1.taxon_id,
       case -- don't try to calculate log(0) -- use rigged exponents of SimSeq
         when bh1.evalue_mant < 0.01 or bh2.evalue_mant < 0.01
           then (bh1.evalue_exp + bh2.evalue_exp) / -2
         else  -- score = ( -log10(evalue1) - log10(evalue2) ) / 2
           (log(10, bh1.evalue_mant * bh2.evalue_mant)
            + bh1.evalue_exp + bh2.evalue_exp) / -2
       end as unnormalized_score
from BetterHit bh1, BetterHit bh2
where bh1.query_id < bh1.subject_id
  and bh1.query_id = bh2.subject_id
  and bh1.subject_id = bh2.query_id
";
  if ($debug==1) {print LOGFILE "\n\n$sql"};
   runSql($sql, "create InParalogTemp table", 'inParalog', '5 min');

}

sub bestHit {
  my $evalueExpThreshold = getConfig("evalueExponentCutoff");
  my $percentMatchThreshold = getConfig("percentMatchCutoff");

  my $sql = "
create table BestHit as
select s.query_id, s.subject_id,
       s.query_taxon_id, s.subject_taxon_id,
       s.evalue_exp, s.evalue_mant
from $sst s, BestQueryTaxonScore cutoff
where s.query_id = cutoff.query_id
  and s.subject_taxon_id = cutoff.subject_taxon_id
  and s.query_taxon_id != s.subject_taxon_id
  and s.evalue_exp <= $evalueExpThreshold
  and s.percent_match >= $percentMatchThreshold
  and (s.evalue_mant < 0.01
       or s.evalue_exp = cutoff.evalue_exp
          and s.evalue_mant = cutoff.evalue_mant)
";
  
  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create BestHit", 'bestHit', '45 min');

 $sql = "
create index best_hit_ix on BestHit(query_id,subject_id)
";

  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create best_hit_ix index on BestHit", 'best_hit_ix', '3 min');
}

sub ortholog {
  my $sql = "
create table OrthologTemp as
select bh1.query_id as sequence_id_a, bh1.subject_id as sequence_id_b,
       bh1.query_taxon_id as taxon_id_a, bh1.subject_taxon_id as taxon_id_b,
       case -- don't try to calculate log(0) -- use rigged exponents of SimSeq
         when bh1.evalue_mant < 0.01 or bh2.evalue_mant < 0.01
           then (bh1.evalue_exp + bh2.evalue_exp) / -2
         else  -- score = ( -log10(evalue1) - log10(evalue2) ) / 2
           (log(10, bh1.evalue_mant * bh2.evalue_mant)
            + bh1.evalue_exp + bh2.evalue_exp) / -2
       end as unnormalized_score
from BestHit bh1, BestHit bh2
where bh1.query_id < bh1.subject_id
  and bh1.query_id = bh2.subject_id
  and bh1.subject_id = bh2.query_id
";
    
  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create OrthologTemp table", 'ortholog', '10 min');

  orthologTaxon('');

}

sub orthologTaxon {
  my ($co) = @_;

  my $coCaps = $co? "Co" : "";
  $co = $co? "coO" : "o";

my $sql = "create table ${coCaps}OrthologTaxon as
select case
         when taxon_id_a < taxon_id_b
         then taxon_id_a
         else taxon_id_b
        end as smaller_tax_id,
        case
          when taxon_id_a < taxon_id_b
          then taxon_id_b
          else taxon_id_a
        end as bigger_tax_id,
        unnormalized_score
      from ${coCaps}OrthologTemp";
  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create ${coCaps}OrthologTaxon table", "${co}rthologTaxon", '10 min');

}

sub normalizeOrthologs {
  normalizeOrthologsSub("", getConfig("orthologTable"));
}

sub normalizeOrthologsSub {
  my ($co, $orthologTable) = @_;

  my $coCaps = $co? "Co" : "";
  $co = $co? "coO" : "o";

  my $sql = "
create table ${coCaps}OrthologAvgScore as
select smaller_tax_id, bigger_tax_id, avg(unnormalized_score) avg_score
from ${coCaps}OrthologTaxon
group by smaller_tax_id, bigger_tax_id
"; 
  
  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create ${coCaps}OrthologAvgScore table", "${co}rthologAvg", '1 min');

  $sql = "create index ${co}orthoAvg_ix on ${coCaps}OrthologAvgScore(smaller_tax_id,bigger_tax_id,avg_score)";
  
  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create ${coCaps}OrthologAvgScore index", "${co}rthologAvgIndex", '1 min');

  $sql = "
  insert into $orthologTable (sequence_id_a, sequence_id_b, taxon_id_a, taxon_id_b, unnormalized_score, normalized_score)
  select ot.sequence_id_a, ot.sequence_id_b, ot.taxon_id_a, ot.taxon_id_b, ot.unnormalized_score, ot.unnormalized_score/a.avg_score
  from ${coCaps}OrthologTemp ot, ${coCaps}OrthologAvgScore a
where least(ot.taxon_id_a, ot.taxon_id_b) = a.smaller_tax_id
    and greatest(ot.taxon_id_a, ot.taxon_id_b) = a.bigger_tax_id
";

  
  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "populate $orthologTable table, including normalized_score", "${co}rthologsNormalization", '0');

}

sub normalizeInParalogs {
  my $inParalogTable = getConfig("inParalogTable");
  my $orthologTable = getConfig("orthologTable");

  ################################################################
  my $sql = "
create table InParalogTaxonAvg as
select avg(i.unnormalized_score) average, i.taxon_id
from InParalogTemp i
group by i.taxon_id
";

  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create InParalogTaxonAvg table", 'inParalogTaxonAvg', '5 min');

  ################################################################

  $sql = "
create table OrthologUniqueId as
select distinct(sequence_id) from (
select sequence_id_a as sequence_id from $orthologTable
union
select sequence_id_b as sequence_id from $orthologTable) i
";

  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create OrthologUniqueId table", 'orthologUniqueId', '5 min');

  ################################################################

  $sql = "create unique index ortholog_unique_id_ix on OrthologUniqueId(sequence_id)";


  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create unique ortholog_unique_id_ix index", 'orthologUniqueIdIndex', '1 min');

  ################################################################

  $sql = "
create table InParalogOrthologTaxonAvg as

 select avg(i.unnormalized_score) average, i.taxon_id
         from InParalogTemp i
         where i.sequence_id_a in
                 (select sequence_id from OrthologUniqueId)
            or i.sequence_id_b in
                 (select sequence_id from OrthologUniqueId)
         group by i.taxon_id
";

  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create InParalogOrthologTaxonAvg table", 'inParalogOrthologTaxonAvg', '5 min');

  ################################################################

  $sql = "
create table InParalogAvgScore as
     select case
            when orth_i.average is NULL
              then all_i.average
              else orth_i.average
            end as avg_score,
            all_i.taxon_id
       from InParalogTaxonAvg all_i LEFT OUTER JOIN InParalogOrthologTaxonAvg orth_i
       ON all_i.taxon_id = orth_i.taxon_id
";

   if ($debug==1) {print LOGFILE "\n\n$sql"};
   runSql($sql, "create InParalogAvgScore table", 'inParalogAvg', '1 min');

  ################################################################

  $sql = "create index inparalog_avg_ix on InParalogAvgScore(taxon_id,avg_score)";


  if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "create InParalogAvgScore index", 'inParalogAvgIndex', '1 min');

  ################################################################

  $sql = "
  insert into $inParalogTable (sequence_id_a, sequence_id_b, taxon_id, unnormalized_score, normalized_score)
  select it.sequence_id_a, it.sequence_id_b, it.taxon_id, it.unnormalized_score, it.unnormalized_score/a.avg_score
  from InParalogTemp it, InParalogAvgScore a
  where it.taxon_id = a.taxon_id
";

   if ($debug==1) {print LOGFILE "\n\n$sql"};
  runSql($sql, "populate $inParalogTable table, including normalized_score", 'inParalogsNormalization', '0');

  ################################################################

}

sub  ortholog2way {
  my $orthologTable = getConfig("orthologTable");

  my $sql = "
create table Ortholog2Way as
-- symmetric closure of Ortholog
select sequence_id_a, sequence_id_b from $orthologTable
union
select sequence_id_b as sequence_id_a, sequence_id_a as sequence_id_b from $orthologTable
";
  
    if ($debug==1) {print LOGFILE "\n\n$sql"};
   runSql($sql, "create Ortholog2Way", 'ortholog2way', '1.5 hours');

}

sub  inParalog2way {
  my $inParalogTable = getConfig("inParalogTable");

  my $sql = "
create table InParalog2Way as
select sequence_id_a, sequence_id_b from $inParalogTable
union
select sequence_id_b as sequence_id_a, sequence_id_a as sequence_id_b from $inParalogTable
";
  
   if ($debug==1) {print LOGFILE "\n\n$sql"};
    runSql($sql, "create InParalog2Way", 'inParalog2way', '1.5 hours');

  $sql = "
create index in2a_ix on InParalog2Way(sequence_id_a, sequence_id_b)
";
  
   if ($debug==1) {print LOGFILE "\n\n$sql"};
   runSql($sql, "index in2a_ix", 'in2a_ix', '1.5 hours');

  $sql = "
create index in2b_ix on InParalog2Way(sequence_id_b, sequence_id_a)
";
  
   if ($debug==1) {print LOGFILE "\n\n$sql"};
    runSql($sql, "index in2b_ix", 'in2b_ix', '1.5 hours');

}

sub  coorthologCandidate {
  my $sql = "
create table InParalogOrthologInParalog as
      select ip1.sequence_id_a, ip2.sequence_id_b
      from InParalog2Way ip1, Ortholog2Way o, InParalog2Way ip2
      where ip1.sequence_id_b = o.sequence_id_a
        and o.sequence_id_b = ip2.sequence_id_a
";
  
   if ($debug==1) {print LOGFILE "\n\n$sql"};
   runSql($sql, "create InParalogOrthologInParalog", 'inParalogOrthologInParalog', '10 min');

  ##################################################################

  $sql = "
create table InParalogOrtholog as
      select ip.sequence_id_a, o.sequence_id_b
      from InParalog2Way ip, Ortholog2Way o
      where ip.sequence_id_b = o.sequence_id_a
";
  
   if ($debug==1) {print LOGFILE "\n\n$sql"};
   runSql($sql, "create InParalogOrtholog", 'inParalogOrtholog', '10 min');

  ##################################################################

  $sql = "
create table CoOrthologCandidate as
select distinct
       least(sequence_id_a, sequence_id_b) as sequence_id_a,
       greatest(sequence_id_a, sequence_id_b) as sequence_id_b
from (select sequence_id_a, sequence_id_b from InParalogOrthologInParalog
      union
      select sequence_id_a, sequence_id_b from InParalogOrtholog) t
";
  
   if ($debug==1) {print LOGFILE "\n\n$sql"};
   runSql($sql, "create CoOrthologCandidate", 'coOrthologCandidate', '10 min');

}

sub  coortholog {
 my $orthologTable = getConfig("orthologTable");
  my $coOrthologTable = getConfig("coOrthologTable");
  my $evalueExpThreshold = getConfig("evalueExponentCutoff");
  my $percentMatchThreshold = getConfig("percentMatchCutoff");

  my $sql = "
create table CoOrthologNotOrtholog as
SELECT cc.sequence_id_a, cc.sequence_id_b
      FROM CoOrthologCandidate cc
      LEFT OUTER JOIN $orthologTable o
      ON cc.sequence_id_a = o.sequence_id_a
      AND cc.sequence_id_b = o.sequence_id_b
      WHERE o.sequence_id_a IS NULL
";

    if ($debug==1) {print LOGFILE "\n\n$sql"};
   runSql($sql, "create CoOrthologNotOrtholog table", 'coOrthologNotOrtholog', '30 min');

##########################################################

  $sql = "
create table CoOrthologTemp as
select candidate.sequence_id_a, candidate.sequence_id_b,
       ab.query_taxon_id as taxon_id_a, ab.subject_taxon_id as taxon_id_b,
       case  -- in case of 0 evalue, use rigged exponent
         when ab.evalue_mant < 0.00001 or ba.evalue_mant < 0.00001
           then (ab.evalue_exp + ba.evalue_exp) / -2
         else -- score = ( -log10(evalue1) - log10(evalue2) ) / 2
           (log(10, ab.evalue_mant * ba.evalue_mant)
            + ab.evalue_exp + ba.evalue_exp) / -2
       end as unnormalized_score
from $sst ab, $sst ba, CoOrthologNotOrtholog candidate
where ab.query_id = candidate.sequence_id_a
  and ab.subject_id = candidate.sequence_id_b
  and ab.evalue_exp <= $evalueExpThreshold
  and ab.percent_match >= $percentMatchThreshold
  and ba.query_id = candidate.sequence_id_b
  and ba.subject_id = candidate.sequence_id_a
  and ba.evalue_exp <= $evalueExpThreshold
  and ba.percent_match >= $percentMatchThreshold
";

    if ($debug==1) {print LOGFILE "\n\n$sql"};
   runSql($sql, "create CoOrthologTemp table", 'coOrtholog', '30 min');

  orthologTaxon('co');
}

close LOGFILE;

sub normalizeCoOrthologs {
  normalizeOrthologsSub("Co", getConfig("coOrthologTable"));
}

sub runSql {
  my ($sql, $msg, $tag, $sampleTime) = @_;

  my $stepNumber = $stepsHash->{$tag};
  die "invalid tag '$tag'" unless $stepNumber;

  if ($skipPast >= $stepNumber) {
    print STDERR "... skipping '$tag'...\n\n";
    return;
  }

  if ($clean ne 'only' && $clean ne 'all') {
      my $t = time();

      print STDERR localtime() . "   $msg  (OrthoMCL-DB V2 took $sampleTime for this step)\n";

      my $stmt = $dbh->prepare($sql) or die DBI::errstr;
      $stmt->execute() or die DBI::errstr;

      my $tt = time() - $t;
      my $hours = int($tt / 3600);
      my $mins = int($tt / 60) % 60;
      if ($hours == 0 && $mins == 0) {$mins = 1};
      my $hoursStr = $hours? "$hours hours and " : "";
      print STDERR localtime() . "   step '$tag' done ($hoursStr$mins mins)\n\n";
  }

  clean($tag) unless ($clean eq 'no');
  exit(1);
}

sub clean {
  my ($tag) = @_;

  my $orthologTable = getConfig("orthologTable");
  my $coOrthologTable = getConfig("coOrthologTable");
  my $inParalogTable = getConfig("inParalogTable");

  my $sqlPrefix = getConfig("dbVendor") eq 'oracle'?
    'select * from all_tables where table_name' :
      'select * from all_tables where table_name';

  my $cleanSqls = $cleanHash->{$tag};
  foreach my $cleanSql (@$cleanSqls) {
    if ($cleanSql) {
      $cleanSql =~ /(\w+) table (\w+)/i || die "invalid clean sql '$cleanSql'";
      my $action = $1;
      my $table = uc($2);  # NOT COMPATIBLE WITH MYSQL!!!
      $table = uc($orthologTable) if $table eq 'Ortholog';
      $table = uc($coOrthologTable) if $table eq 'CoOrtholog';
      $table = uc($inParalogTable) if $table eq 'InParalog';
      if ($action eq 'drop') {
	my $stmt = $dbh->prepare("$sqlPrefix = '$table'" ) or die DBI::errstr;
	$stmt->execute() or die DBI::errstr;
	return unless $stmt->fetchrow();
      }
      my $stmt = $dbh->prepare($cleanSql) or die DBI::errstr;
      print STDERR localtime() . "   cleaning: $cleanSql\n";
      $stmt->execute() or die DBI::errstr;
      print STDERR localtime() . "   done\n";
    }
  }
}

sub cleanall {
    foreach my $tag (keys (%$cleanHash)) {
	clean($tag);
    }
}

sub getConfig {
  my ($prop) = @_;
  die "can't find property $prop in config file" unless $config->{$prop};
  return $config->{$prop};
}

sub usage {
  my $stepsString;
  map { $stepsString .= "  $_->[0]\n" } @steps;

  print "
Find edges for OrthoMCL.

usage: orthomclEdges config_file cleanup=[yes|no|only|all] <startAfter=TAG>

where:
  config_file : see below
  cleanup     : clean up temp tables? 
                   yes=clean as we go; 
                   no=don't clean as we go; 
                   only=just clean, do nothing else; 
                   all=just clean, plus clean InParalog, Ortholog and CoOrtholog tables.
  startAfter  : optionally start after a previously completed step. see below for TAGs

Database Input:
  - SimilarSequences table containing all-v-all BLAST hits
  - InParalog, Ortholog, CoOrtholog tables - created but empty

Database Output:
  - Populated InParalog, Ortholog and CoOrtholog tables

Standard Output:
  - matrix file as expected by MCL.

Standard Error:
  - logging info

NOTE: the database login in the config file must have update/insert/truncate privileges on the tables specified in the config file.

Sample Config File:

dbVendor=oracle  (or mysql)
dbConnectString=dbi:Oracle:orthomcl
dbLogin=my_db_login
dbPassword=my_db_password
similarSequencesTable=SimilarSequences
orthologTable=Ortholog
inParalogTable=InParalog
coOrthologTable=CoOrtholog
interTaxonMatchView=InterTaxonMatch
percentMatchCutoff=50
evalueExponentCutoff=-5

Names of TAGs to use in startAfter (look in log file to see last one run)
$stepsString
";
  exit(1);
}

